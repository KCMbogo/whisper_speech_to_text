Now I told you that Selenium can interact with the browser. Now for it to be able to interact with the browser, here we have just seen how you can open the browser and go to a specific URL in the browser. Now for Selenium to interact with your browser, it has to know which elements I am going to interact with. My elements I mean the HTML elements, the tags, the CSS elements, the CSS selectors and things of that kind. So you have to be a bit familiar. It's not much but you have to be with family with HTML and CSS because most of the browser, every browser, every website has an HTML structure. So we have to leverage those elements like the div, the class names, the names, the attributes inside of those tags. Those are the way that Selenium is going to interact with your browser. It will detect a specific tag, it will detect a specific element, it will detect a specific CSS selector. Then from that detection it goes on to manipulate what happens either clicking or any action that as long as it first gets the element or the component, then it can decide what am I going to do to click it or to pass some value to it or do anything else. So for that we can just say maybe let's go to google.com. We are going to go to google.com. And time dot sleep. This time let's point 60 seconds or maybe 180. You know there is a better way of making sure that this does not close the browser but it does for later. This is just some easier way of doing it for now. So if I run this and here it opens the google site. In google we can find that we have a search box here. Now we want through Selenium that it opens this google website, then after opening it here it detects the search component, then types in any value without I am typing it manually. But Selenium should detect the search component and type the value, then click search. So for that to happen we must know this component, this search component, how is it represented in the HTML structure. So what I did is just I clicked the right click then click respect it to open this chrome developer. Yeah. So we go straight to where the search component is. This is the search main, this search component, this is how it is represented using text area. Now using text area they represented. Now in text area there are different tags. I mean there are different attributes. The class area controls, auto focus, title, value, this area whatever. We have name, we have role, we have roles, we have spell check. All these are the different attributes inside text area, element or tag. So we can use any of these attributes or we can use the text area element or the tag itself to detect the search box. But before doing that, let's just cross this. Before doing that let me take you to how to locate different elements. So in Selenium. So in Selenium here from the site we see locating element. There are various strategies to locate elements in a page. You can use most appropriate one for your case. Selenium provides the following method to locate elements in a page. So to locate an element in a page you can just use find element for a single element or find elements to find the elements of the same kind. Now my focus is here. We can find an element by using its ID. All by using its name, all x path I can show you x path later. All by using link text, all partial link text, all by using tag name, all by using class name, all by using CSS selector. Let's search for something. Let's search here google.com. So here is google.com. We can inspect. I think it's still loading my network. No, not yet. I also need it. Let's expand this. So the text area component is here. I mean the search component. This is also treated represented. Now here they say we can select it by using ID. Selenium can detect that any element in the page or in the site using its ID. So you can't see. Is there an ID in this component? Yeah, here it is. So ID up APG is the weird ID but that's how Google kept it. So you can go just find element by ID then you specify the name. So in our case here the name will be that weird name that you just saw. APG, QB or whatever. That is what was taken by name. Now we are not going straight to use, you know, it's not best to use some complicated format. For example, if you use the ID. This is a weird ID to use. So what you are going to do is we are going to look for another simple way of representing it. They say by name. You can't here and look for name attributes and we find it here. So name equals Q. Okay, this is a bit simple and clear and easy to read. 
So we can use name to represent it. They also say by expert. Now how do you detect the expert? Simple yes. In this specific component, right click. Then copy, copy expert. When you copy the expert, let me test it here so you can see structure. So this is how the expert structure looks like. This is the expert. But we are not going to use that. You can use any of this. You can use tag name. Now by tag name is text area. Text area is the tag. So here you can say find element by tag name and you put text area. So it will detect any component or any component that has a tag name text area. You can also detect using class name or CSS select. So class name, this is the class and the class name is a bit weird as you can see. And CSS selector. So CSS selector is if you are aware of CSS, so you know how selectors work. So simply just when you are in CSS file, how do you call HTML elements to style them in the CSS file? That method of calling it like maybe let's see here. Let's see maybe how CSS selector looks like. We can say maybe roll it. So we are going to this side so with driver. Okay. That. So we are going to find the search component. So that we can pass the value that we want to search into that component. Here, here we open the browser. We go to this page that we will go to that page. Then in that page we want to find the driver. We want to find the search component. We want to find the search component. So Selenium provides find element. Now there are two methods. There is this one here, find driver. Find element and there is driver. Find elements. So find element will simply return only a single element. It is best use this when you are sure that what I will get, there is a certain way to get will be only a unique element. For example, you can just come back to the Google here and click Ctrl F. Wait, you know, technology. If you click this button here it will open an AI assistance. You can ask, there are how many text area, text area, what elements. Then the AI will help you find out. It will analyze the page and count. So it says there are two text area elements. So we only want to get this one here, this specific text area where we are going to search, where we are going to input our search value. So if there are two, it means that to be complicated. We are going to get more than one and we only want this one. So we cannot use text area, we cannot use tag name, text area use because we read that we can use a tag name and the tag name is text area. So we cannot use text area now because we only want a single element but text area will return two because there are two text area elements in this page. Now we can use id but there is weird, you know the name is, this name is bad. You can just, but you can use it, you can just copy the name and go back and filter by id but I'm not going to use this id. I would prefer to use name. Why one because most of the search area components of Google, when people are writing code to detect the search area component, they use the name attribute name because q, q stands for query. So this is unique, I don't think there is another element with this attribute. So we are going to use name equals to q. Back to our isolation, I mean back to our code. So we can search, we can use find element. Now find element takes in two arguments. The first one is buy, buy keyword document, shortcut require, they don't explain but buy means this element you want to find. You want to find it using which method. Now which method if you come back to this page, buy, I want to find it by id or name or expert or link text or class name or say selector, this is the buy value. You see, so we say by name, this is what we want to use name. So back to our code, back to our code, we are going to find it by name. But where are these selectors present? Where are these selectors? So we have to import a function, I can say or a method or a class that contains these different selectors. So from selenium, the trip driver, good call, good buy, import buy. So in this here module or buy this class, buy the class, it's a class that contains the different methods for us to access the elements. So you can see here buy contains id, so it will be buy id, like here, buy expert, buy link text, buy text, buy name, buy tag name. So we are going to use this by name. So here it will be buy, dot name. So we are going to find this search bar by name. Now what's the name? So the second argument it receives is a string, which is a value. So the value that we want to check is q. What does it mean? It simply means, we want to find it by the attribute called name whose value is q. So that is what it means. Oh wait, here, here. We are finding it by attribute name whose value is q. So that is what it means. 
You know what I call it. So what happens if we find this? When you detect the search element, so to this point here, Selenium already finds the search element and it stores it in a variable called search. After keeping it in a variable called search, what next is we go search dot send keys. Now what does send keys mean? It means you already found the search element, so pass this value to that search element. Simple. Send keys. So just pass this text or pass this value to the search element. What value do we want to pass? You can say okay, maybe, maybe, cut the line. No, no, no, no, no, no, no, no, no, no, no, no, no, no, no, no, no, no, no, no, no, no, okay, let's say, Python, Python programming. So it will send keys. They're not. Then search dot send keys again, but this time it will be a bit different. You know, they are here. The first send keys will pass this string to the search component. The second one is here to click after passing the element to click search. So we have to simulate the clicking. Now how is this done? We can use send keys, we can use send keys, which will need us again to import something from Selenium.webcriber.com. .keys. import keys. So keys, this one that we've imported, represents the keyboard keys. So after typing, after passing the, this text, after passing this text to the search component, what next is we want to click enter. So we can say keys. Okay, keys. But return. You can see keys. Return stands for enter. Add, alt, arrow, down, arrow, left, arrow, up, backspace. All these are the different buttons. And you can see they are the common buttons, all the keys in your keyboard. So in our case, it's return. So what this means is pass that text, click enter. It will search. This is one way of doing it. And we will stick with it for now. So if I run that, it will search, go to Google. After going to Google, it has to pass the string. Yeah, it has to pass the string. It click enter. But then we get some time, bit problem. So sometimes this happens that Google has some security measures. So it will detect, it would like to verify if you have a robot or not. Because this automation is like creating a bot for the web. Now, there are ways to walk around this. But they are bit complicated. So that's a tutorial for another time. For now, let's just try and fill it manually. Then, down. You see, it's searched and returned some outputs. So Python programming, this is what it returned. So, nice. Now I say there are two ways of doing this. Search sent his click enter. Oh, there is this another way which I have never tested. But let's see, search submit. Create a terminal, run again. To open the browser, text some time. Then it should put in the text. There are Python programming. And I submitted a source for the bot patch. For the robot detection, we just do it manually first for now. But later, I will show you how to walk around this. But for now, let's just verify it manually. Verification complete. And we get the same output. So that is it. Okay, I have to clear the channel. Now, we submitted. And nice. So, you can either use this here, which simulates clicking enter. Or you can use search to submit which yes submits. I sometimes, I mostly prefer to use keys to enter. The source to bring the idea of the simulation idea to live, simulating that you are clicking enter. But you can also use submit. Now, after searching, what's next? Okay. We searched. Then, now, let's... Let's go to another... Another subtopic. Or I can say another feature of Selenium. I see there is much better way of doing this. This time, we'll sleep. But for now, this is the best. It's the easiest one for now. But before we get to that, let's see something. There are times when you try to get the URL like this. It will give an error. Like maybe the most common error is... Element is not interactable. You get an error like... Element is not interactable. Now, what this means is that maybe depending on your internet connection, that the element that you are trying to interact with at the moment is not yet active. Or has not yet loaded well. This happens. And because the browser is loaded using... You know, the components that are loaded in the browser may use different times to load. Maybe the search bar might take some more time to load depending on your internet connection. Or maybe any other element that you want to interact with takes quite... And I like the amount of time to load. So to walk around this problem, we use a Selenium package that is called Web Driver Weight. Web Driver Weight. So we can do something like... From Selenium... The web driver load support. .UI... Import Web Driver Weight. And also from Selenium Web Driver Weight, what is this next package here? That support, import, import, expended conditions, yes. So, these two packages work together. These two work together. So, what do they mean? They simply mean...

Web Driver, the tweet, simply means... Weight for this amount of time before you do anything. Let's comment this first. And see how it can go about this. So, for example, this way here, we use such as... ...you can drive a refined element by name, value, kills, of it, fine. But, as I said, it may happen that the element is not yet loaded. And we are trying to access it here right now, here. We are trying to access an element, but it may happen that that element that we are trying to access at the time is not yet loaded. So, how to go about this? We are going to wait until that element is loaded, then we can continue with other processes to avoid the error. That is where Web Driver.Weit comes in. So, it's just like Web Driver.Weit. Weight for it. Okay, you pass in the driver, which is the variable that contains your instantiation of the driver of the Chrome driver. And the second one is timeout, the second argument. It's timeout. That means, a timeout simply means, wait for this amount of time until this element is loaded. If this time passes and the element is not loaded, then throw an error. That is what it means. So, mostly we put 10 which is in seconds. So, it means, wait for 10 seconds. Until the same element is loaded. Now, which element? We want to load the such element. Here, we can say as EC. So, load until. So, wait for 10 seconds until what? Until, this is where the expected conditions coming this one, we imported it as EC. So, expected condition, load, presence of element located. And you pass in a locator.

Okay, no, no. By...name.

So, this means, wait for 10 seconds until we find an element that has an attribute name with the value q. Simple. Simple like that. So, we pass in here, we can say such. It's equal to that one.

And we can check this. It should work the same actually. So, such if and keys are here. Yeah, okay. It should work the same actually. But this is the safest way of doing it. Because sometimes it may happen, I'm repeating again, it may happen, that's the most common error in using this seven impact page. Okay, we have an error here. Okay. Okay, okay, okay. We are using two submit functions. So, what happens is, it's such as for this programming, then click center. And if you are picking enter, then it clicks enter again. See? So, you can run again. Open that. It's such. Opened. So, you're going to do this manually again. Stares. Verify. There. It opens. So, I say this should work the same. So, if you get the same result, then it's fine. But this is just the safest way of going around this. Using web drive or to click and expected condition. Expected conditions contains all the functions that you expect, for example. I say EC dot, a lattice present. These are all the different functions that are contained inside expected condition. Elementage which to include invisibility of element, visibility, new. So, there are different functions to check for you to check conditions for you to check. And this is the safest way of doing it. And expected condition is always, not always I can say. Most of the time use the inside web drive or to wait. Because web drive or to wait says the time, then expected condition says the condition to check within that time frame. So, that is it for that. Next up, options. From Selenium. The web drive or Chrome.Options. Import. What are options? Now what are options? A web drive has many different options. I can say. Let me go to a site that will explain more clearly. Here it is. Now options are specific to browsers. So, since I am using Chrome, I will use the Chrome options. I think they are almost common in some sense. And in other functionalities they differ. So Chrome, Edge, you can choose, I will put this link in the description. And you will check. You can choose your specific browser here and see how the options look in your specific browser. So, for Chrome. Yeah, okay, okay. First, let's just search. What are options in Selenium Python package? No, we have the internet that our hands so we can just use it. And as usual, that AI is already there to help. Options in Selenium Python package allow you to customize the behavior of web browser using automated testing. They enable you to get various configurations such as running the browser in headless mode, disabling extensions or specifying the browser version. So, you can use these options to specify the browser version. Disabling extensions as you know, Chrome has different extensions. Now, if you want to run while disabling some extensions like any of the extensions that you would like to disable, options allow you to do that. Now, headless mode simply means, as of now, the way we are running things is that we run, then a browser appears, then we see the whole automation process gone. But headless mode makes it running the background. That the browser won't pop up. Everything will be running on the background, and while you only see the output in the terminal, that is what headless mode means. Now, you can go in deep, read more of our options, but our focus on the code. Now, options in Chrome, we can start with this one here, the first. Okay, back to our code. So, if you are using Safari, it will be Safari.Options, Firefox, it will be Firefox Detotions, and like that. And here we put the options. So, we will say like Chrome options, physical options, instantiate this variable with the class of options. Then, we can add an argument. So, I think we passed that first one there. So, options just had some specific functionalities to the browser. As of now, when we run our browser, it opens up in a modified version. You see, the window is small. But, what if we want that when it starts, the window starts full screen. So, we can add an argument. Start, maximize. You see? And, we can log back to the site and see. Here, start, maximize, common use, the arguments include start, maximize headless and use a data directory. All these are the different options that are used. Also, just detach, detach. Now, I told you that there is a much easier way of making the browser not to shut down every time it runs. Then, after a while, it shuts down. The touch is used for that. So, setting the detach parameter to true will keep the browser open after the process has ended. As long as the quit command is not sent to the driver. So, this is the way of doing it. Now, you know, you can just copy this. And, you come here and paste it. And, yeah, it's not options for us to scroll options. So, it will be scroll options that add experimental option, detach, true. So, this will keep the browser window open even if the process has ended by doing that we won't need this anymore. And, yeah, so these are the two options that we can use for now. So, you copy that and we paste it here. Add experimental option, detach, true. So, using this, we won't need this time to sync. Yeah, I'm repeating this because I saw while I was talking the code viewer is not seen. So, we don't need this anymore because we put the touch through. This will keep the driver there window open. Now, back to... Yeah, we can go back to the options page. That side to every red things. So, there are many arguments like this one here. Excluding arguments. Chromeriver has several default argumented users to start the browser. If you don't want those arguments, add it. Pass them to Exclude switches. A common example is to turn the pop-up broker back on a full list of. So, there are many different options. But, we'll start with the basics one. And, these are the basic ones. You can go in research for your own more about these Chrome options. There are many, many, many. There are even options to add the... Now, I remember I said that the Chrome profile. When your Chrome browser starts, it starts while you are seeing that. So, there is an option that is used to make to add the... To open the browser as if you assigned these... It opens the browser with your Chrome profile. Signed in. So, with that, you can just pass here options. It's equal to Chrome options. Pass that to the driver. And, running this, what do we expect? To open the Google Chrome... Yeah, let's change this. You can say that. Go. Go. And, to wait, such... 5-100 times... Detach. It's my... So, it will open a... Maximized... Window.

Error. Ah, there is also an option to hide this argument here. So, it's... So, opening. Hopefully, it's not protected. You see. You can see something protection here. OK.

OK, no one. This is taking quite some time. Yes, yes. Go back to our... OK, Google Chrome.







